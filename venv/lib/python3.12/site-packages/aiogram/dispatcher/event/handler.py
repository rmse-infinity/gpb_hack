# hr_llm_bot/handlers.py
from typing import List, Dict, Any

from aiogram import F, Router, Bot
from aiogram.filters import Command, CommandObject, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import Message
from langchain_core.messages import BaseMessage

from llm_service import LLMService
from states import InterviewStates
from config import AVAILABLE_POSITIONS, INCOMPETENT_VERDICT, MAX_MESSAGES_PER_SIDE
from promt import get_main_system_prompt

router = Router()

# Инициализация LLM сервиса
llm_s = None
try:
    llm_s = LLMService()
except Exception:
    # Логирование здесь было бы полезно, но по запросу оно убрано
    pass


# --- Обработчики ---

@router.channel_post(Command(commands=["start"]))  # Обрабатывает /start и /start <аргументы>
async def cmd_start_handler(message: Message, state: FSMContext, command: CommandObject, bot: Bot):
    hr_bot_id = bot.id  # Получаем ID текущего бота

    # Игнорировать команду, если она отправлена самим ботом (маловероятно для /start, но для полноты)
    if message.from_user and message.from_user.id == hr_bot_id:
        return

    args = command.args
    await state.clear()  # Очищаем состояние для новой сессии в канале
    await state.set_state(InterviewStates.waiting_for_position)
    initial_system_prompt = get_main_system_prompt()
    await state.update_data(
        dialog_history_raw=[{"role": "system", "content": initial_system_prompt}],
        message_count_candidate=0
    )

    if args == "1":
        await message.answer(
            "Привет! Я HR-бот, предназначенный для проведения первичных технических собеседований. "
            "Я помогу оценить кандидатов на позиции Data Scientist, Data Engineer, Data Analyst, MLOps Engineer, и Project Manager. "
            "Когда кандидат (или кандидат-бот) будет готов, он может отправить свое первое сообщение, указав желаемую позицию, "
            "или использовать фразу, содержащую 'мой бот', чтобы начать диалог."
        )
    else:  # Обычный /start или /start с другими аргументами
        await message.answer(
            "HR-бот перезапущен для этого канала. Ожидаю первое сообщение от кандидата."
        )


# Единый обработчик для первого сообщения от кандидата или триггера "мой бот"
@router.channel_post(
    F.text,
    StateFilter(None, InterviewStates.waiting_for_position)  # Сработает, если нет состояния или ожидаем позицию
)
async def handle_initial_candidate_interaction(message: Message, state: FSMContext, bot: Bot):
    hr_bot_id = bot.id
    # Игнорировать, если сообщение от самого HR-бота (например, его собственный ответ попал в обработку)
    if message.from_user and message.from_user.id == hr_bot_id:
        return
    # Кандидат (даже если это бот) должен иметь from_user. Игнорируем анонимные посты канала.
    if not message.from_user:
        return

    user_text = message.text.strip()
    current_fsm_state = await state.get_state()

    # Если состояние не было установлено (None) или нужно обновить системный промпт
    if current_fsm_state is None:
        await state.set_state(InterviewStates.waiting_for_position)
        initial_system_prompt = get_main_system_prompt()
        await state.update_data(
            dialog_history_raw=[{"role": "system", "content": initial_system_prompt}],
            message_count_candidate=0
        )
    else:  # Состояние waiting_for_position, проверим наличие системного промпта
        current_data = await state.get_data()
        if not current_data.get('dialog_history_raw') or \
                (current_data.get('dialog_history_raw') and current_data['dialog_history_raw'][0]['role'] != 'system'):
            initial_system_prompt = get_main_system_prompt()
            await state.update_data(
                dialog_history_raw=[{"role": "system", "content": initial_system_prompt}]
                # message_count_candidate уже должен быть 0 из /start или предыдущей логики
            )

    if not llm_s:
        await message.answer("Извините, сервис для обработки запросов (LLM) временно недоступен. Попробуйте позже.")
        return

    current_data_for_llm = await state.get_data()
    dialog_history_raw: List[Dict[str, Any]] = current_data_for_llm.get('dialog_history_raw', [])

    # if "мой бот" in user_text.lower():
    # Здесь можно добавить логирование или специальную метку, если фраза "мой бот" важна для статистики
    # logger.info(f"Обнаружена фраза 'мой бот' в первом сообщении от {message.from_user.id}") # Пример

    history_for_llm: List[BaseMessage] = llm_s.history_to_langchain_format(dialog_history_raw)
    bot_response_text = await llm_s.get_llm_response(history_for_llm, user_input=user_text)

    # Это первое сообщение от кандидата, которое обрабатывается для начала интервью
    await state.update_data(message_count_candidate=1)

    # Перечитываем dialog_history_raw, т.к. оно могло быть только что инициализировано
    current_data_after_count = await state.get_data()
    dialog_history_raw_for_add = current_data_after_count.get('dialog_history_raw', [])

    if bot_response_text and "ошибка" not in bot_response_text.lower():
        updated_dialog_history_raw = llm_s.add_message_to_raw_history(
            list(dialog_history_raw_for_add), "user", user_text
        )
        updated_dialog_history_raw = llm_s.add_message_to_raw_history(
            updated_dialog_history_raw, "assistant", bot_response_text
        )
        await state.update_data(dialog_history_raw=updated_dialog_history_raw)
        await message.answer(bot_response_text)
        await state.set_state(InterviewStates.interview_in_progress)
    else:
        await message.answer(
            bot_response_text or "Произошла ошибка при обработке вашего первого сообщения или позиция не распознана. Пожалуйста, попробуйте еще раз или администратор может перезапустить сессию командой /start."
        )
        # Сбрасываем счетчик, так как попытка начать интервью не удалась
        await state.update_data(message_count_candidate=0)
        # Состояние остается waiting_for_position для следующей попытки


@router.channel_post(F.text, InterviewStates.interview_in_progress)
async def process_interview_message(message: Message, state: FSMContext, bot: Bot):
    hr_bot_id = bot.id
    if message.from_user and message.from_user.id == hr_bot_id: return
    if not message.from_user: return

    user_text = message.text.strip()

    if not llm_s:
        await message.answer("Извините, сервис для обработки запросов временно недоступен. Попробуйте позже.")
        return

    current_data = await state.get_data()
    dialog_history_raw: List[Dict[str, Any]] = current_data.get('dialog_history_raw', [])
    message_count_candidate: int = current_data.get('message_count_candidate', 0)

    message_count_candidate += 1

    history_for_llm_call: List[BaseMessage] = llm_s.history_to_langchain_format(dialog_history_raw)
    user_input_for_llm = user_text

    bot_response_text = await llm_s.get_llm_response(history_for_llm_call, user_input=user_input_for_llm)

    if bot_response_text and "ошибка" not in bot_response_text.lower():
        updated_dialog_history_raw = llm_s.add_message_to_raw_history(list(dialog_history_raw), "user", user_text)
        updated_dialog_history_raw = llm_s.add_message_to_raw_history(updated_dialog_history_raw, "assistant",
                                                                      bot_response_text)

        await state.update_data(
            dialog_history_raw=updated_dialog_history_raw,
            message_count_candidate=message_count_candidate
        )
        await message.answer(bot_response_text)

        if bot_response_text.startswith("[") and bot_response_text.endswith("]"):
            clean_verdict = bot_response_text.strip("[]")
            if clean_verdict in AVAILABLE_POSITIONS or clean_verdict == INCOMPETENT_VERDICT.strip("[]"):
                await state.set_state(InterviewStates.finished)
            else:  # Нераспознанный вердикт в скобках
                if message_count_candidate >= MAX_MESSAGES_PER_SIDE:
                    await message.answer(
                        f"Модуль принятия решений дал непредвиденный ответ, и лимит сообщений исчерпан. Результат: {INCOMPETENT_VERDICT}")
                    await state.set_state(InterviewStates.finished)
        elif message_count_candidate >= MAX_MESSAGES_PER_SIDE:
            await message.answer(INCOMPETENT_VERDICT)
            await state.set_state(InterviewStates.finished)
    else:
        # Сохраняем увеличенный счетчик сообщений, даже если была ошибка LLM
        await state.update_data(message_count_candidate=message_count_candidate)
        await message.answer(bot_response_text or "Произошла ошибка при генерации ответа. Попробуйте ответить еще раз.")


@router.channel_post(F.text, InterviewStates.finished)
async def process_message_after_finish(message: Message, state: FSMContext, bot: Bot):
    hr_bot_id = bot.id
    if message.from_user and message.from_user.id == hr_bot_id: return
    if not message.from_user: return

    await message.answer(
        "Собеседование уже завершено. Для начала нового диалога администратор канала может использовать команду /start."
    )


@router.channel_post(~F.text)  # Обработка нетекстовых сообщений в канале
async def handle_non_text_channel_post(message: Message, bot: Bot):
    hr_bot_id = bot.id
    if message.from_user and message.from_user.id == hr_bot_id: return
    # Можно также добавить if not message.from_user: return, если не хотим отвечать на анонимные медиа

    await message.answer("Пожалуйста, отправляйте только текстовые сообщения в рамках собеседования.")